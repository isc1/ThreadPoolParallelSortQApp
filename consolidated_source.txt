# === README.md ===
# ThreadPoolParallelSortQApp
Multithreaded Example app in Qt 5 by Claude
#

# === main.cpp ===
// === main.cpp ===
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
#

# === mainwindow.cpp ===
// === mainwindow.cpp ===
#include "mainwindow.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QThreadPool>
#include <QRunnable>
#include <QThread>
#include <QElapsedTimer>
#include <QMutex>
#include <algorithm>
#include <random>
#include <atomic>
#include <iostream>
#include <iomanip>

// Global mutex for thread-safe printing
QMutex printMutex;

// Task to sort a chunk of the vector
class SortTask : public QRunnable {
private:
    std::vector<int>* data;
    int startIndex;
    int endIndex;
    int taskId;

public:
    SortTask(std::vector<int>* vec, int start, int end, int id)
        : data(vec), startIndex(start), endIndex(end), taskId(id) {
        setAutoDelete(true);  // QThreadPool will delete this after run()
    }

    void run() override {
        {
            QMutexLocker locker(&printMutex);
            std::cout << "[Thread " << QThread::currentThreadId() << "] Task " << taskId
                      << " sorting range [" << startIndex << "-" << endIndex << ")" << std::endl;
        }

        // Sort this chunk of the vector
        std::sort(data->begin() + startIndex, data->begin() + endIndex);

        {
            QMutexLocker locker(&printMutex);
            std::cout << "[Thread " << QThread::currentThreadId() << "] Task " << taskId
                      << " completed sorting" << std::endl;
        }
    }
};

// Task to merge sorted chunks
class MergeTask : public QRunnable {
private:
    std::vector<int>* data;
    int start1, end1;  // First sorted range
    int start2, end2;  // Second sorted range
    int taskId;

public:
    MergeTask(std::vector<int>* vec, int s1, int e1, int s2, int e2, int id)
        : data(vec), start1(s1), end1(e1), start2(s2), end2(e2), taskId(id) {
        setAutoDelete(true);
    }

    void run() override {
        {
            QMutexLocker locker(&printMutex);
            std::cout << "[Thread " << QThread::currentThreadId() << "] Merge Task " << taskId
                      << " merging ranges [" << start1 << "-" << end1 << ") and ["
                      << start2 << "-" << end2 << ")" << std::endl;
        }

        // Create temporary vector for merged result
        std::vector<int> temp;
        temp.reserve(end2 - start1);

        // Merge the two sorted ranges
        std::merge(data->begin() + start1, data->begin() + end1,
                   data->begin() + start2, data->begin() + end2,
                   std::back_inserter(temp));

        // Copy back to original vector
        std::copy(temp.begin(), temp.end(), data->begin() + start1);

        {
            QMutexLocker locker(&printMutex);
            std::cout << "[Thread " << QThread::currentThreadId() << "] Merge Task " << taskId
                      << " completed" << std::endl;
        }
    }
};

class ParallelSorter {
private:
    QThreadPool* threadPool;
    std::vector<int>* data;

public:
    ParallelSorter(std::vector<int>* vec) : data(vec) {
        threadPool = new QThreadPool();
        int totalCores = QThread::idealThreadCount();
        int usableCores = std::max(1, totalCores - 1);  // Leave 1 core for OS

        threadPool->setMaxThreadCount(usableCores);

        std::cout << "System has " << totalCores << " cores" << std::endl;
        std::cout << "Using " << usableCores << " threads for sorting" << std::endl;
        std::cout << "Main thread ID: " << QThread::currentThreadId() << std::endl;
    }

    ~ParallelSorter() {
        delete threadPool;
    }

    void parallelSort() {
        int vectorSize = data->size();
        int numThreads = threadPool->maxThreadCount();
        int chunkSize = vectorSize / numThreads;

        std::cout << "=== PHASE 1: Sorting chunks in parallel ===" << std::endl;
        std::cout << "Vector size: " << vectorSize << std::endl;
        std::cout << "Chunk size: " << chunkSize << std::endl;

        // Phase 1: Sort chunks in parallel
        for (int i = 0; i < numThreads; i++) {
            int start = i * chunkSize;
            int end = (i == numThreads - 1) ? vectorSize : (i + 1) * chunkSize;

            SortTask* task = new SortTask(data, start, end, i);
            threadPool->start(task);
        }

        // Wait for all sorting tasks to complete
        threadPool->waitForDone();

        std::cout << "=== PHASE 2: Merging sorted chunks ===" << std::endl;

        // Phase 2: Merge sorted chunks
        // We'll do a tree-like merge for efficiency
        int numChunks = numThreads;
        int mergeTaskId = 0;

        while (numChunks > 1) {
            int newNumChunks = 0;

            for (int i = 0; i < numChunks; i += 2) {
                if (i + 1 < numChunks) {
                    // Merge two adjacent chunks
                    int start1 = (i * vectorSize) / numThreads;
                    int end1 = ((i + 1) * vectorSize) / numThreads;
                    int start2 = end1;
                    int end2 = ((i + 2) * vectorSize) / numThreads;

                    if (i + 2 == numChunks) {
                        end2 = vectorSize;  // Last chunk might be larger
                    }

                    MergeTask* mergeTask = new MergeTask(data, start1, end1, start2, end2, mergeTaskId++);
                    threadPool->start(mergeTask);

                    newNumChunks++;
                }
            }

            threadPool->waitForDone();
            numChunks = newNumChunks;
        }

        std::cout << "=== Sorting complete! ===" << std::endl;
    }
};

// Helper function to verify the vector is sorted
bool isSorted(const std::vector<int>& vec) {
    for (size_t i = 1; i < vec.size(); i++) {
        if (vec[i] < vec[i-1]) {
            return false;
        }
    }
    return true;
}

// Helper function to print first and last elements
void printSample(const std::vector<int>& vec, const std::string& label) {
    QMutexLocker locker(&printMutex);
    std::cout << label << std::endl;

    // Print first 10 elements
    std::cout << "First 10 elements: ";
    int firstCount = std::min(10, (int)vec.size());
    for (int i = 0; i < firstCount; i++) {
        std::cout << vec[i];
        if (i < firstCount - 1) std::cout << ", ";
    }
    std::cout << std::endl;

    // Print last 10 elements
    std::cout << "Last 10 elements: ";
    int lastCount = std::min(10, (int)vec.size());
    for (size_t i = vec.size() - lastCount; i < vec.size(); i++) {
        std::cout << vec[i];
        if (i < vec.size() - 1) std::cout << ", ";
    }
    std::cout << std::endl;
}

// MainWindow constructor implementation
MainWindow::MainWindow(QWidget* parent) : QWidget(parent) {
    setWindowTitle("Parallel Sort Demo");
    setFixedSize(400, 200);

    // Create layout
    QVBoxLayout* layout = new QVBoxLayout(this);

    // Create widgets
    statusLabel = new QLabel("Click 'Start Sorting' to begin parallel sort demo");
    statusLabel->setWordWrap(true);
    startButton = new QPushButton("Start Sorting");

    // Add to layout
    layout->addWidget(statusLabel);
    layout->addWidget(startButton);

    // Connect button
    connect(startButton, &QPushButton::clicked, this, &MainWindow::runSortingDemo);

    std::cout << "GUI Application started. Check Application Output for sorting details." << std::endl;
}

// MainWindow destructor implementation
MainWindow::~MainWindow() {
    // Destructor
}

// MainWindow::runSortingDemo implementation
void MainWindow::runSortingDemo() {
    startButton->setEnabled(false);
    statusLabel->setText("Sorting in progress... Check Application Output for details.");

    // Create a vector of random integers
    data.resize(VECTOR_SIZE);

    // Fill with random numbers
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 1000000);

    std::cout << "\nGenerating " << VECTOR_SIZE << " random integers..." << std::endl;
    for (int i = 0; i < VECTOR_SIZE; i++) {
        data[i] = dis(gen);
    }

    printSample(data, "\nOriginal vector (unsorted):");

    // Time the parallel sort
    QElapsedTimer timer;
    timer.start();

    // Perform parallel sort
    ParallelSorter sorter(&data);
    sorter.parallelSort();

    qint64 parallelTime = timer.elapsed();

    // Verify the result
    bool sorted = isSorted(data);
    std::cout << "\nVector is sorted: " << (sorted ? "true" : "false") << std::endl;

    printSample(data, "\nSorted vector:");

    std::cout << "\nParallel sort took: " << parallelTime << " ms" << std::endl;

    // For comparison, let's time a single-threaded sort
    std::cout << "\nNow testing single-threaded sort for comparison..." << std::endl;

    // Regenerate random data
    for (int i = 0; i < VECTOR_SIZE; i++) {
        data[i] = dis(gen);
    }

    timer.restart();
    std::sort(data.begin(), data.end());
    qint64 singleThreadTime = timer.elapsed();

    std::cout << "Single-threaded sort took: " << singleThreadTime << " ms" << std::endl;
    std::cout << "Speedup: " << std::fixed << std::setprecision(2)
              << (double)singleThreadTime / parallelTime << "x" << std::endl;

    statusLabel->setText("Sorting complete! Check Application Output for results.");
    startButton->setEnabled(true);
}
#

# === mainwindow.h ===
// === mainwindow.h ===
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QWidget>
#include <vector>  // Add this include

class QLabel;
class QPushButton;

class MainWindow : public QWidget
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void runSortingDemo();

private:
    QLabel* statusLabel;
    QPushButton* startButton;
    std::vector<int> data;
    static const int VECTOR_SIZE = 1000000;
};

#endif // MAINWINDOW_H
#

